"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pagination = void 0;
const discord_js_1 = require("discord.js");
const defaultEmojis = {
    first: "⬅️",
    previous: "◀️",
    next: "▶️",
    last: "➡️",
};
const pagination = async (options) => {
    const { message, embeds, button, time, max, customFilter } = options;
    let currentPage = 1;
    const getButtonData = (name) => {
        return button.find((btn) => btn.name === name);
    };
    const generateButtons = (state) => {
        const checkState = (name) => {
            if (["first", "previous"].includes(name) &&
                currentPage === 1)
                return true;
            if (["next", "last"].includes(name) &&
                currentPage === embeds.length)
                return true;
            return false;
        };
        const names = ["first", "previous", "next", "last"];
        return names.reduce((accumulator, name) => {
            accumulator.push(new discord_js_1.MessageButton()
                .setEmoji(getButtonData(name)?.emoji || defaultEmojis[name])
                .setCustomId(name)
                .setDisabled(state || checkState(name)));
            return accumulator;
        }, []);
    };
    const components = (state) => [
        new discord_js_1.MessageActionRow().addComponents(generateButtons(state)),
    ];
    const changeFooter = (embed) => {
        if (embed.footer.text) {
            return embed.setFooter(`${embed.footer.text} - Page ${currentPage} of ${embeds.length}`, embed.footer.iconURL);
        }
        return embed.setFooter(`Page ${currentPage} of ${embeds.length}`);
    };
    await message.channel.send({
        embeds: [changeFooter(embeds[0])],
        components: components(),
    });
    const defaultFilter = (interaction) => interaction.user.id === message.author.id;
    const filter = customFilter || defaultFilter;
    const collectorOptions = () => {
        const opt = {
            filter,
            componentType: "BUTTON",
        };
        if (max)
            opt["max"] = max;
        if (time)
            opt["time"] = time;
        return opt;
    };
    const collector = message.channel.createMessageComponentCollector(collectorOptions());
    collector.on("collect", (interaction) => {
        const id = interaction.customId;
        if (id === "first")
            currentPage = 1;
        if (id === "previous")
            currentPage--;
        if (id === "next")
            currentPage++;
        if (id === "last")
            currentPage === embeds.length;
        interaction.update({
            embeds: [changeFooter(embeds[currentPage])],
            components: components(),
        });
    });
    collector.on("end", (interactions) => {
        interactions.first().update({
            components: components(true),
        });
    });
};
exports.pagination = pagination;
//# sourceMappingURL=pagination.js.map